# Hash tables / maps are efficient to saerch for an element i,e Constant time operation
# Issues:  Hash function may be expensive, Collision may happen
# Maps characteristic is: key -value pair
# We can look up something by using key and go to the location and get the value
# Sets: List has orders, Set does not have order and does not have any repeatetive elements in it
# Maps is a set based data structure (similar to list being an array based data structure)
#  A Group of keys in a map is set

# Introduction to maps

# Maps concept  = built-in feature as Dictionary in Python

ex_name = {} #Initializing a dictionary
ex_name['a'] = 1
ex_name['b'] = 2
print(ex_name)
print(type(ex_name))

print(f"First letter", ex_name['a']) # This statement calls two steps 
#a) Go t othe key labeld 'a'  and 
# b) find its' value
ex_name['a'] = 4
print(f"Re-assigned letter", ex_name['a'])

# Example -2
# Dictionaries are very flexible and we can store a wide variety of structures and values

dict_two = {}
dict_two['a'] = [1]
dict_two['b'] = [2]
dict_two['c'] = [3]
print(dict_two)

dict_two['a'].append('second element in the list')
print(dict_two)

# Dictionary of Dictionaries
print("Current")

locations = {'North America': {'USA': ['California']}}
print(type(locations))
# locations is the dictionary of dictonaries
# Continent: dictionary
# ['California] is the list which acts as the 'value' for a dictionary

# Adding a new list

locations['asia'] = {'india':['Bangalore']}
locations['asia']['india'].append('New Delhi')
locations['North America']['USA'].append('Atlanta')
locations['Africa'] = {'Egypt':['Cyro']}
locations['asia']['China'] = ['Shanghai']
print(locations)

# We access like: Key-> key-> key - VALUE


# TODO: Print a list of all cities in the USA in alphabetic order.
cities_in_USA = locations['North America']['USA']

for city in sorted(cities_in_USA):
    print(city)

# TODO: Print all cities in Asia, in alphabetic order, next to the name of the country

results = []
for country, cities in locations['asia'].items():
    print(country)
    for city in cities:
        results.append('{}, {}'.format(city, country))

results = sorted(results)

for city in results:
    print(city)
    
# Hash function
# Purpose of the hash function is to convert the given value into a hash code (index of an array normally) that can be stored and retrived easily
# Input: Some value which is 'hasable'  and Output: An integer (normally which can be used as an array index)
# Choosing the right hash function is very important
# It includes
# a) Taking a last two digits of a given input i.e 1234532 is assigned the value of 32 (i.e THe hash function's purpose is to slice the last two elements)
# This is becase the last two digits are at random. There is a draback
# b) or reminder by dividing using a constant number

# Collions

# When the hash code generated by Hash function is same for two different inputs, then the collision happens.
# Two main ways to fix:
# a) Change the hash functionm so we will have more than enough values to store the values. Will need bigger array when we store the values
# b) Keep the original hash function. Change the way we store the value in each slot i.e store more than one value in a collection (buckets
#  Design a hash function - by taking into account - spread outs the values, lot of space, bucket concept (max. 2 or 3 values in a collection)
# We can also use a second hash function inside the bucket;  this is good when we have well spread out data but with few buckets with large number of values

